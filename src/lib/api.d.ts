/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/sessions": {
    /**
     * Get All Sessions
     * @description Returns a list of sessions.
     */
    get: operations["getAllSessions"];
  };
  "/sessions/{sessionId}": {
    /**
     * Get Session by Session ID
     * @description Returns a session.
     */
    get: operations["getSession"];
  };
  "/users": {
    /**
     * Search Users by username
     * @description Returns a list of users.
     */
    get: operations["searchUsers"];
  };
  "/users/{userId}": {
    /**
     * Get User by User ID
     * @description Returns a single user.
     */
    get: operations["getUser"];
  };
  "/users/{userId}/contacts": {
    /**
     * Get User Contacts
     * @description Retrieve the list of contacts for the user. Used to get your own contact list.
     */
    get: operations["getUserContacts"];
  };
  "/userSessions": {
    /**
     * Create a user session
     * @description Login to the Resonite service and create a user session.
     */
    post: operations["createUserSession"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** CorrespondingWorldId */
    SessionCorrespondingWorldId: {
      recordId: string;
      ownerId: string;
    };
    /** SessionUser */
    SessionUser: {
      username: string;
      userID?: string;
      /** @description Whether the user is currently in the session. */
      isPresent: boolean;
      /**
       * @description The output device of the user.
       * Headless users will not have this property.
       */
      outputDevice?: number;
    };
    /** Session */
    Session: {
      /** @description May contain rich text tags for TextMeshPro, such as HTML */
      name: string;
      /** @description May contain rich text tags for TextMeshPro, such as HTML */
      description?: string;
      correspondingWorldId?: components["schemas"]["SessionCorrespondingWorldId"];
      tags: string[];
      sessionId: string;
      normalizedSessionId: string;
      /** @description If the host is not a registered user, this is undefined. */
      hostUserId?: string;
      /**
       * Format: uuid
       * @description If the host is not a registered user, this is undefined.
       */
      hostUserSessionId?: string;
      hostMachineId: string;
      hostUsername: string;
      compatibilityHash: string;
      appVersion: string;
      headlessHost: boolean;
      sessionURLs: string[];
      parentSessionIds: string[];
      nestedSessionIds: string[];
      sessionUsers: components["schemas"]["SessionUser"][];
      /** Format: uri */
      thumbnailUrl: string;
      joinedUsers: number;
      activeUsers: number;
      totalJoinedUsers: number;
      totalActiveUsers: number;
      maxUsers: number;
      mobileFriendly: boolean;
      /** Format: date-time */
      sessionBeginTime: string;
      /** Format: date-time */
      lastUpdate: string;
      /** @enum {string} */
      accessLevel: "Anyone" | "RegisteredUsers";
      hideFromListing: boolean;
      hasEnded: boolean;
      isValid: boolean;
      universeId?: string;
    };
    /** UserTag */
    UserTag: string[];
    /** UserBadge */
    UserBadge: {
      id?: string;
      ownerId?: string;
    };
    /** UserProfile */
    UserProfile: {
      iconUrl?: string;
      tagline?: string;
      displayBadges: components["schemas"]["UserBadge"][];
      description?: string;
    };
    /** UserMigratedData */
    UserMigratedData: {
      username: string;
      userId: string;
      quotaBytes: number;
      usedBytes: number;
      quotaBytesSources?: {
        base?: number;
        patreon?: number;
        paid?: number;
        translator?: number;
        mmc21_honorary?: number;
      };
      /** Format: date-time */
      registrationDate: string;
    };
    /** User */
    User: {
      id: string;
      username: string;
      normalizedUsername: string;
      /** Format: date-time */
      registrationDate: string;
      isVerified: boolean;
      isLocked: boolean;
      supressBanEvasion: boolean;
      "2fa_login": boolean;
      tags?: components["schemas"]["UserTag"];
      profile?: components["schemas"]["UserProfile"];
      migratedData?: components["schemas"]["UserMigratedData"];
    };
    /** Contact */
    Contact: {
      /** @description The contact's user ID */
      id?: string;
      /** @description The contact's username */
      contactUsername?: string;
      /**
       * @description The contact's status
       * This property appears to be `Accepted` even though the request to add a contact has not been accepted. Check `isAccepted` to see if the request was actually accepted.
       * @enum {string}
       */
      contactStatus?: "Accepted";
      /** @description The request to add a contact was accepted. */
      isAccepted?: boolean;
      /** Format: date-time */
      latestMessageTime?: string;
      /** @description This may indicate that the contact was migrated from an old platform. */
      isMigrated?: boolean;
      isCounterpartMigrated?: boolean;
      /** @description This is the userId you included in your query when making the request. */
      owner?: string;
    };
    /** UserSessionAuthenticationPassword */
    UserSessionAuthenticationPassword: {
      /** @enum {string} */
      $type: "password";
      password: string;
      /** @default null */
      recoveryCode: string | null;
    };
    /** UserSessionAuthenticationSessionToken */
    UserSessionAuthenticationSessionToken: {
      /** @enum {string} */
      $type: "sessionToken";
      isValid: boolean;
      sessionToken: string;
    };
    /** UserSessionsRequest */
    UserSessionsRequest: {
      /** @default null */
      ownerId?: string | null;
      /** @description Maybe you need either `username` or `email`. */
      username?: string | null;
      /** @description Maybe you need either `username` or `email`. */
      email?: string | null;
      authentication: components["schemas"]["UserSessionAuthenticationPassword"] | components["schemas"]["UserSessionAuthenticationSessionToken"];
      /** @description Maybe any hex value is allowed. e.g. `a`. */
      secretMachineId: string;
      /**
       * @description If set to `true`, a token valid for one month will be issued.
       * If set to `false`, a token valid for one day will be issued.
       * @default false
       */
      rememberMe: boolean;
    };
    /** UserSessionEntity */
    UserSessionEntity: {
      userId: string;
      token: string;
      /** Format: date-time */
      created: string;
      /** Format: date-time */
      expire: string;
      remenberMe: boolean;
      secretMachineIdHash: string;
      secretMachineIdSalt: string;
      logoutUrlClientSide: boolean;
      sessionLoginCounter: number;
      sourceIP: string;
      partitionKey: string;
      rowKey: string;
      eTag?: string | null;
    };
    /** UserSessionConfigFile */
    UserSessionConfigFile: {
      path: string;
      content: string;
    };
    /** UserSession */
    UserSession: {
      entity: components["schemas"]["UserSessionEntity"];
      configFiles?: components["schemas"]["UserSessionConfigFile"][];
    };
  };
  responses: {
    /** @description Returns a list of sessions. */
    GetAllSessionsResponse: {
      content: {
        "application/json": components["schemas"]["Session"][];
      };
    };
    /** @description Returns a list of sessions. */
    GetSessionResponse: {
      content: {
        "application/json": components["schemas"]["Session"];
      };
    };
    /** @description Returns a users */
    SearchUsersResponse: {
      content: {
        "application/json": components["schemas"]["User"][];
      };
    };
    /** @description Returns a user. */
    GetUserResponse: {
      content: {
        "application/json": components["schemas"]["User"];
      };
    };
    /** @description Returns a list of contacts. */
    GetUserContactsResponse: {
      content: {
        "application/json": components["schemas"]["Contact"][];
      };
    };
    /** @description OK */
    UserSessionsResponse: {
      content: {
        "application/json": components["schemas"]["UserSession"];
      };
    };
  };
  parameters: {
    /** @description Include empty headless sessions */
    includeEmptyHeadless?: boolean;
    /** @description Minimum number of active users */
    minActiveUsers?: number;
    /** @description The session ID */
    sessionId: string;
    /**
     * @description The username to search.
     * @example Eai
     */
    name?: string;
    /**
     * @description The user ID. Should start with `U-`.
     * @example U-Eai
     */
    userId: string;
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Get All Sessions
   * @description Returns a list of sessions.
   */
  getAllSessions: {
    parameters: {
      query?: {
        includeEmptyHeadless?: components["parameters"]["includeEmptyHeadless"];
        minActiveUsers?: components["parameters"]["minActiveUsers"];
      };
    };
    responses: {
      200: components["responses"]["GetAllSessionsResponse"];
    };
  };
  /**
   * Get Session by Session ID
   * @description Returns a session.
   */
  getSession: {
    parameters: {
      path: {
        sessionId: components["parameters"]["sessionId"];
      };
    };
    responses: {
      200: components["responses"]["GetSessionResponse"];
    };
  };
  /**
   * Search Users by username
   * @description Returns a list of users.
   */
  searchUsers: {
    parameters: {
      query?: {
        name?: components["parameters"]["name"];
      };
    };
    responses: {
      200: components["responses"]["SearchUsersResponse"];
    };
  };
  /**
   * Get User by User ID
   * @description Returns a single user.
   */
  getUser: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["GetUserResponse"];
      /** @description Invalid user ID */
      400: {
        content: never;
      };
      /** @description User not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get User Contacts
   * @description Retrieve the list of contacts for the user. Used to get your own contact list.
   */
  getUserContacts: {
    parameters: {
      path: {
        userId: components["parameters"]["userId"];
      };
    };
    responses: {
      200: components["responses"]["GetUserContactsResponse"];
      /** @description Unauthorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Create a user session
   * @description Login to the Resonite service and create a user session.
   */
  createUserSession: {
    parameters: {
      header: {
        /** @description Maybe any hex value is allowed. e.g. `a`. */
        UID: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UserSessionsRequest"];
      };
    };
    responses: {
      200: components["responses"]["UserSessionsResponse"];
      /** @description Bad Request */
      400: {
        content: never;
      };
      /** @description Unauthorized */
      401: {
        content: never;
      };
    };
  };
}
